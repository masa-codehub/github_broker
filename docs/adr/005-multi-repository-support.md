# 5. マルチリポジトリ対応

## Context
現状のシステムでは、Redisキーの設計にリポジトリを識別する情報が含まれていません。例えば、`issue_lock` や `open_issues` といったキーは、リポジトリ固有の情報を保持していません。このため、複数のリポジトリを同時に扱う場合、キーの衝突が発生し、データの一貫性が損なわれる可能性があります。結果として、現在の設計では単一のリポジトリしか安全に扱うことができません。

## Decision
将来的なマルチリポジトリ対応を可能にするため、すべてのRedisキーにリポジトリを一意に識別するためのプレフィックスを追加します。具体的なプレフィックスの形式は `repo_{owner}_{repo_name}:` とします。

> **注意:** `owner` や `repo_name` にアンダースコア（_）、コロン（:）、その他の特殊文字が含まれる場合、キーの一意性を保証するためにURLエンコード（`encodeURIComponent`）などのエスケープ処理を必須とします。  

例:
- `issue_lock_{issue_id}` -> `repo_{owner}_{repo_name}:issue_lock_{issue_id}`
- `open_issues` -> `repo_{owner}_{repo_name}:open_issues`
- `agent_current_task:{agent_id}` -> `repo_{owner}_{repo_name}:agent_current_task:{agent_id}`

このプレフィックスは、Redisキーを使用するすべての箇所で適用されるものとします。

### 代替案の検討
プレフィックスとしてリポジトリID（例: `repo_{repo_id}:`）を使用する案も検討されました。リポジトリIDは一意な数値であるため、キー長が短くなる、owner名やrepo名に含まれる特殊文字を考慮する必要がなくなるといったメリットがあります。しかし、デバッグ時にキーから直接リポジトリを人間が識別するのが困難になるというデメリットを考慮し、今回は `repo_{owner}_{repo_name}:` 形式を採用します。

## Consequences
### メリット
- **マルチリポジトリ対応:** 複数のGitHubリポジトリを同時に安全に扱うことが可能になります。各リポジトリのデータは独立して管理されるため、キーの衝突による問題が解消されます。
- **スケーラビリティの向上:** 将来的にシステムが扱うリポジトリ数が増加しても、Redisキーの管理が容易になり、システムの拡張性が向上します。
- **明確なデータ分離:** Redis内のデータがどのリポジトリに属するのかが明確になり、デバッグや運用がしやすくなります。

### 既存コードへの影響範囲
- **Redisキー生成ロジックの変更:** Redisキーを生成しているすべての箇所で、新しいプレフィックスを追加するロジックを導入する必要があります。
- **既存データの移行:** マルチリポジトリ対応を完全に実施する場合、既存の単一リポジトリのRedisデータを新しいキー形式に移行する必要があります。移行戦略としては、段階的移行（新旧キーを並行して運用し、徐々に新形式へ移行）、一括移行（システム停止中に全データを一度に変換）、または並行稼働（両形式を一定期間併用）などが考えられます。ダウンタイムについては、段階的移行や並行稼働を選択することで最小化または回避可能ですが、一括移行の場合は短時間のダウンタイムが発生する可能性があります。詳細な移行方針は別途検討します。
- **テストの更新:** Redisキーの生成ロジックが変更されるため、関連する単体テストおよび統合テストの更新が必要になります。
