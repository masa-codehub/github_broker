# ADR 006: ハイブリッドポーリングとサーバーサイドロジックへの移行

## Status

Accepted

## Context

当初のアーキテクチャでは、エージェント（クライアント）は固定的な「役割」を持っていました。そして、その役割に対応するIssueをクライアント自身がGitHub APIから検索し、タスクを選択する必要がありました。この設計には、以下の課題がありました。

1.  **静的な役割分担による非効率性:** エージェントの役割が固定されているため、対応する役割のIssueがなければ、そのエージェントはタスクが割り当てられず、遊休状態になってしまいました。これにより、システム全体のスループットが低下していました。
2.  **タスク処理順序の一貫性:** Issueを処理する優先順位のロジックが各クライアントに分散していると、ロジックの更新時に修正漏れが起きる可能性があります。その結果、意図しない順序でタスクが処理され、後工程での手戻りや、関連タスクの修正漏れに繋がるリスクがありました。

これらの課題、特に将来的に「静的な役割分担による非効率性」を解決するための基盤として、まずはタスク選択のロジックをサーバーサイドに一元化する必要がありました。

## Decision

これらの課題を解決するため、アーキテクチャを以下の通り変更します。

### 1. ハイブリッドアーキテクチャの採用

-   **バックグラウンドポーリング:** 独立したポーリングサービスが、定期的にGitHub APIからオープンなIssueを取得し、Redisに一括でキャッシュします。これにより、APIコールを大幅に削減します。
-   **APIサーバー:** エージェントからのタスク要求を受け付け、Redisにキャッシュされた情報を基に、高速にタスクの割り当て処理を行います。

### 2. サーバーサイドロジックの一元化

-   **役割ベースのタスク選択:** エージェントの役割 (`agent_role`) に基づいてタスクをフィルタリングするロジックを、サーバー側の`TaskService`に実装します。エージェントはリクエスト時に自身の役割を伝えるだけで、適切なタスク候補が選択されます。
-   **プロンプト生成:** `GeminiExecutor` をサーバーサイドで利用し、選択されたタスクに基づいてエージェントが実行すべきプロンプトを生成します。クライアントは受け取ったプロンプトを実行するだけのシンクライアントになります。

### 3. ロングポーリングの導入

-   タスク要求API (`/request-task`) にロングポーリングを実装します。割り当て可能なタスクがない場合、サーバーは即座にレスポンスを返さず、指定されたタイムアウト時間までタスクの出現を待ち受けます。これにより、クライアント側の無駄な待機ループやリクエスト頻度の調整が不要になります。

### 4. `needs-review` ラベルによるワークフローの導入

-   エージェントがタスクを完了し、次のタスクを要求した際に、完了したIssueに `needs-review` ラベルを自動的に付与します。
-   タスク選択ロジックは `needs-review` ラベルが付いたIssueを候補から除外します。これにより、開発中のタスクとレビュー待ちのタスクが明確に分離され、ワークフローが整理されます。

## Consequences

-   **パフォーマンス向上:** Redisキャッシュの利用により、タスク要求時のレスポンスタイムが大幅に短縮されます。
-   **API利用効率の改善:** GitHub APIへのリクエストがバックグラウンドポーリングに集約されるため、レート制限のリスクが大幅に低減します。
-   **クライアントの実装簡素化:** タスク選択やプロンプト生成のロジックが不要になるため、エージェント（クライアント）の開発が容易になります。
-   **サーバー負荷の軽減:** ロングポーリングにより、クライアントからの不要なポーリングリクエストがなくなり、サーバーの負荷が軽減されます。
-   **ワークフローの明確化:** `needs-review` ラベルの導入により、タスクの状態遷移が明確になり、開発プロセスとレビュープロセスの連携がスムーズになります。
-   **タスク選択ロジックの現状:** 現状の実装では、役割でフィルタリングされた後、Issue番号の昇順でタスクが選択されます。より高度な優先度付け（P0, P1ラベルなど）は、将来的な改善タスクとなります。
