# ADR 006: ハイブリッドポーリングとサーバーサイドロジックへの移行

## Status

Accepted

## Context

当初のアーキテクチャでは、エージェント（クライアント）がタスクを要求するたびにGitHub APIを直接呼び出していました。また、タスク選択やプロンプト生成のロジックがクライアント側に分散する可能性がありました。この設計には、以下の課題がありました。

1.  **パフォーマンスとAPIレート制限:** タスク要求のたびにGitHub APIを呼び出すと、エージェント数が増加した場合にAPIのレート制限に抵触しやすく、またレスポンスも遅延します。
2.  **クライアントの複雑化:** 各エージェントがタスク選択やプロンプト生成のロジックを持つと、クライアントの実装が複雑になり、役割ごとにロジックの重複や差異が生まれる可能性があります。
3.  **無駄なリクエスト:** 割り当て可能なタスクが存在しない場合でも、クライアントはタスクを求めて短間隔でリクエストを繰り返すため、サーバーとクライアント双方に無駄な負荷がかかります。
4.  **不明確なワークフロー:** 開発とレビューの間のタスクの引き渡しが、ラベルなどの仕組みで明確に定義されていませんでした。

## Decision

これらの課題を解決するため、アーキテクチャを以下の通り変更します。

### 1. ハイブリッドアーキテクチャの採用

-   **バックグラウンドポーリング:** 独立したポーリングサービスが、定期的にGitHub APIからオープンなIssueを取得し、Redisに一括でキャッシュします。これにより、APIコールを大幅に削減します。
-   **APIサーバー:** エージェントからのタスク要求を受け付け、Redisにキャッシュされた情報を基に、高速にタスクの割り当て処理を行います。

### 2. サーバーサイドロジックの一元化

-   **役割ベースのタスク選択:** エージェントの役割 (`agent_role`) に基づいてタスクをフィルタリングするロジックを、サーバー側の`TaskService`に実装します。エージェントはリクエスト時に自身の役割を伝えるだけで、適切なタスク候補が選択されます。
-   **プロンプト生成:** `GeminiExecutor` をサーバーサイドで利用し、選択されたタスクに基づいてエージェントが実行すべきプロンプトを生成します。クライアントは受け取ったプロンプトを実行するだけのシンクライアントになります。

### 3. ロングポーリングの導入

-   タスク要求API (`/request-task`) にロングポーリングを実装します。割り当て可能なタスクがない場合、サーバーは即座にレスポンスを返さず、指定されたタイムアウト時間までタスクの出現を待ち受けます。これにより、クライアント側の無駄な待機ループやリクエスト頻度の調整が不要になります。

### 4. `needs-review` ラベルによるワークフローの導入

-   エージェントがタスクを完了し、次のタスクを要求した際に、完了したIssueに `needs-review` ラベルを自動的に付与します。
-   タスク選択ロジックは `needs-review` ラベルが付いたIssueを候補から除外します。これにより、開発中のタスクとレビュー待ちのタスクが明確に分離され、ワークフローが整理されます。

## Consequences

-   **パフォーマンス向上:** Redisキャッシュの利用により、タスク要求時のレスポンスタイムが大幅に短縮されます。
-   **API利用効率の改善:** GitHub APIへのリクエストがバックグラウンドポーリングに集約されるため、レート制限のリスクが大幅に低減します。
-   **クライアントの実装簡素化:** タスク選択やプロンプト生成のロジックが不要になるため、エージェント（クライアント）の開発が容易になります。
-   **サーバー負荷の軽減:** ロングポーリングにより、クライアントからの不要なポーリングリクエストがなくなり、サーバーの負荷が軽減されます。
-   **ワークフローの明確化:** `needs-review` ラベルの導入により、タスクの状態遷移が明確になり、開発プロセスとレビュープロセスの連携がスムーズになります。
-   **タスク選択ロジックの現状:** 現状の実装では、役割でフィルタリングされた後、Issue番号の昇順でタスクが選択されます。より高度な優先度付け（P0, P1ラベルなど）は、将来的な改善タスクとなります。
