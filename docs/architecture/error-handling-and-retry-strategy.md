# エラーハンドリングとリトライ戦略

このドキュメントは、`github_broker`が外部システムとの連携や内部処理でエラーに遭遇した際の、ハンドリングとリトライに関する戦略を定義します。

## 1. 基本方針

-   **フェイルファスト:** 予期せぬエラーや、処理の続行が不可能なエラーが発生した場合は、速やかに処理を中断し、詳細なエラーログを出力します。
-   **リソースの確実な解放:** タスクのロックなど、共有リソースを獲得した後の処理でエラーが発生した場合は、`finally`節などを用いて、必ずリソースを解放し、デッドロックを防ぎます。
-   **現時点でのリトライ戦略:** 現在、指数バックオフのような積極的なリトライ戦略は実装されていません。リトライは、主に次回のポーリングサイクルに委ねられています。

## 2. 主要なエラーシナリオと現在のハンドリング

### シナリオ1: Redisへの接続・操作エラー

-   **発生箇所:** `TaskService`が`RedisClient`を呼び出す全ての箇所。
-   **例外:** `redis.exceptions.RedisError`
-   **現在のハンドリング:**
    1.  `ERROR`レベルで例外情報をロギングします。
    2.  現在のポーリングサイクルを中断します。
    3.  次のポーリングサイクル（`POLLING_INTERVAL_SECONDS`後）で、処理が再試行されることを期待します。

### シナリオ2: GitHub APIへの接続・操作エラー

-   **発生箇所:** `TaskService`が`GitHubClient`を呼び出す全ての箇所。
-   **例外:** `github.GithubException`
-   **現在のハンドリング:**
    1.  `ERROR`レベルで例外情報をロギングします。
    2.  現在の処理を中断します。
    3.  タスク割り当ての途中で失敗した場合、取得したロックの解放や、付与したラベルのロールバック処理を試みます。
    4.  最終的な復旧は、次回のポーリングサイクルに委ねられます。

### シナリオ3: Gemini APIへの接続・操作エラー

-   **発生箇所:** `TaskService`が`GeminiClient`を呼び出す箇所。
-   **例外:** `requests.exceptions.RequestException` など。
-   **現在のハンドリング:**
    1.  `ERROR`レベルで例外情報をロギングします。
    2.  タスク割り当てプロセス全体を失敗とみなし、ロックの解放とラベルのロールバックを行います。

### シナリオ4: 分散ロックの取得失敗

-   **発生箇所:** `TaskService`の`_find_first_assignable_task`内。
-   **例外:** `redis_client.acquire_lock()`が`False`を返す。
-   **現在のハンドリング:**
    1.  `WARNING`レベルで「タスクが他のエージェントによってロックされている」旨をロギングします。
    2.  例外は発生させず、現在のIssueをスキップして次の候補Issueの処理に移ります。これは正常な競合状態であり、エラーではありません。

## 3. 将来的な改善点

-   **指数バックオフによるリトライ:** 一時的なネットワークエラーなど、時間をおけば回復する可能性が高いエラーに対しては、`tenacity`ライブラリなどを導入し、指数バックオフ付きのリトライを実装することを検討します。
-   **サーキットブレーカー:** 特定の外部サービスでエラーが多発する場合に、一時的にそのサービスへのリクエストを遮断し、システム全体の負荷を軽減するサーキットブレーカーパターンの導入を検討します。
-   **デッドレターキュー:** 複数回のリトライにも失敗したタスクを、専用のキュー（デッドレターキュー）に退避させ、後から手動で原因調査や再処理を行える仕組みを検討します。
