---
title: 'Feat: DIコンテナを導入し依存関係を管理'
labels: 'enhancement, architecture'
---

## 概要

現在、`interface/api.py`において、`GitHubClient`, `RedisClient`, `GeminiClient`といった依存オブジェクトが直接インスタンス化されています。この方法はシンプルですが、アプリケーションの規模が拡大するにつれて、依存関係の管理が複雑化する可能性があります。

依存性注入（DI）コンテナライブラリを導入し、依存関係の解決を一元的に管理する仕組みを構築します。

## あるべき姿

- DIコンテナがアプリケーションのエントリーポイント（`main.py`など）で設定される。
- 各コンポーネント（`TaskService`, `FastAPI`エンドポイントなど）は、DIコンテナを通じて必要な依存オブジェクトを受け取る。
- オブジェクトの生成と利用が分離され、各コンポーネントの責務がより明確になる。
- テスト時に、特定の依存関係をモックオブジェクトに差し替えることが容易になる。

## タスク

1.  DIコンテナライブラリ（例: `dependency-injector`）をプロジェクトに導入する。
2.  `containers.py`のような設定ファイルを作成し、`GitHubClient`, `RedisClient`, `GeminiClient`, `TaskService`などのプロバイダを定義する。
3.  `interface/api.py`および`main.py`を修正し、DIコンテナから`TaskService`のインスタンスを取得するよう変更する。
4.  依存関係の解決がコンテナによって行われることを確認する。
5.  既存のテストがDIコンテナの導入後も正常に動作することを確認する。

## 期待される効果

- 依存関係の可視性が向上し、アプリケーション全体の構成を理解しやすくなる。
- コンポーネントの再利用性が高まる。
- ユニットテストやインテグレーションテストにおけるモックの利用が簡素化され、テストコードの保守性が向上する。
